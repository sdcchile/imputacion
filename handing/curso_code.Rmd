---
title: "Handling Missing Data with Imputations in R"
author: "Michał Oleszak"
sub: "Michał is a Machine Learning Engineer with a background in statistics and econometrics, holding degrees from Erasmus University Rotterdam, The Netherlands and Warsaw School of Economics, Poland. He is the author of the pmpp R package for forecasting with panel data. Having worked at a data science consultancy, he has gained experience in squeezing value from messy and incomplete data. He's currently shaping the future at an AI startup. Visit his homepage to find out more."
date: "22/2/2023"
output:
  html_document:
    theme: paper
    toc: yes
    toc_depth: 4
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '4'
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, warning=FALSE, message=FALSE}
library(dplyr)
library(ggplot2)
biopics <- read.csv("~/edi_imp/handing/biopics.csv")
```


 
# Chapter 1

Missing data is everywhere. The process of filling in missing values is known as imputation, and knowing how to correctly fill in missing data is an essential skill if you want to produce accurate predictions and distinguish yourself from the crowd. In this course, you’ll learn how to use visualizations and statistical tests to recognize missing data patterns and how to impute data using a collection of statistical and machine learning models. You’ll also gain decision-making skills, helping you decide which imputation method fits best in a particular situation. Finally, you’ll learn to incorporate uncertainty from imputation into your inference and predictions, making them more robust and reliable.

<iframe src="https://inechile-my.sharepoint.com/personal/jibustosm_ine_gob_cl/_layouts/15/embed.aspx?UniqueId=14c653a3-f98d-41fd-a74a-1080a6916067&embed=%7B%22ust%22%3Atrue%2C%22hv%22%3A%22CopyEmbedCode%22%7D&referrer=OneUpFileViewer&referrerScenario=EmbedDialog.Create" width="640" height="360" frameborder="0" scrolling="no" allowfullscreen title="Cap_1_s1.mp4"></iframe>

## Sesión 1

### Linear regression with incomplete data

Missing data is a common problem and dealing with it appropriately is extremely important. Ignoring the missing data points or filling them incorrectly may cause the models to work in unexpected ways and cause the predictions and inferences to be biased.

In this chapter, you will be working with the `biopics` dataset. It contains information on a number of biographical movies, including their earnings, subject characteristics and some other variables. Some of the data points are, however, missing. The original data comes with the `fivethirtyeight` R package, but in this course, you will work with a slightly preprocessed version.

In this exercise, you will get to know the dataset and fit a linear regression model to explain a movie's earnings. Let's begin!


### Actividad 

Print the first 10 observations of the `biopics` data and get familiar with the variables.

```{r}
# Print first 10 observations
head(biopics, 10)

# Get the number of missing values per variable
biopics %>%
	is.na() %>% 
	colSums()

# Fit linear regression to predict earnings
model_1 <- lm(earnings ~ country + year + sub_type, 
              data = biopics)

# Fit linear regression to predict earnings
model_2 <- lm(earnings ~ country + year + sub_type + sub_race, 
              data = biopics)

```

### Recognizing missing data mechanisms

In this exercise, you will face six different scenarios in which some data are missing. Try assigning each of them to the most likely missing data mechanism. As a refresher, here are some general guidelines:

If the reason for missingness is purely random, it's MCAR.
If the reason for missingness can be explained by another variable, it's MAR.
If the reason for missingness depends on the missing value itself, it's MNAR.


![alt text](/home/jbustos/edi_imp/handing/procesos.png "Title")

### t-test for MAR: data preparation

Great work on classifying the missing data mechanisms in the last exercise! Of all three, MAR is arguably the most important one to detect, as many imputation methods assume the data are MAR. This exercise will, therefore, focus on testing for MAR.

You will be working with the familiar `biopics` data. The goal is to test whether the number of missing values in `earnings` differs per subject's gender. In this exercise, you will only prepare the data for the t-test. First, you will create a dummy variable indicating missingness in `earnings`. Then, you will split it per gender by first filtering the data to keep one of the genders, and then pulling the dummy variable. For filtering, it might be helpful to print `biopics`'s `head()` in the console and examine the gender variable.


```{r}
# Create a dummy variable for missing earnings
biopics <- biopics %>% 
  mutate(missing_earnings = is.na(earnings))

# Pull the missing earnings dummy for males
missing_earnings_males <- biopics %>% 
  filter(sub_sex == "Male") %>% 
  pull(missing_earnings)

# Pull the missing earnings dummy for females
missing_earnings_females <- biopics %>% 
  filter(sub_sex == "Female") %>% 
  pull(missing_earnings)
```

### t-test for MAR: interpretation

In the last exercise, you have prepared two vectors with the missing earnings values for each gender: missing_earnings_males and missing_earnings_females. Both of them are available in your workspace. Now you can perform the t-test to check if their means are significantly different from each other! Let's do some serious statistical testing!

```{r}
# Run the t-test
t.test(missing_earnings_males, missing_earnings_females)
```



## Sesión 2

<iframe src="https://inechile-my.sharepoint.com/personal/jibustosm_ine_gob_cl/_layouts/15/embed.aspx?UniqueId=2485fae1-8cf5-4218-9a43-cd2460aa6286&embed=%7B%22ust%22%3Atrue%2C%22hv%22%3A%22CopyEmbedCode%22%7D&referrer=OneUpFileViewer&referrerScenario=EmbedDialog.Create" width="640" height="360" frameborder="0" scrolling="no" allowfullscreen title="Cap1_s2.mp4"></iframe>

### Aggregation plot

The aggregation plot provides the answer to the basic question one may ask about an incomplete dataset: in which combinations of variables the data are missing, and how often? It is very useful for gaining a high-level overview of the missingness patterns. For example, it makes it immediately visible if there is some combination of variables that are often missing together, which might suggest some relation between them.

In this exercise, you will first draw the aggregation plot for the `biopics` data and then practice making conclusions based on it. Let's do some plotting!

```{r}
# Load the VIM package
library(VIM)

# Draw an aggregation plot of biopics
biopics %>% 
	aggr(combined = TRUE, numbers = TRUE)
```

### Question

Based on the aggregation plot you have just created, which of the following statements is false?

Possible Answers

10% of the observations have missing values in both `earnings` and `sub_race`.

There are more missing values in `sub_race` than in `earnings`.

42% of the observations have no missing entries.

There are exactly two variables in the `biopics` data that have missing values.

## Sesión 3

<iframe src="https://inechile-my.sharepoint.com/personal/jibustosm_ine_gob_cl/_layouts/15/embed.aspx?UniqueId=65581489-dcd4-45f7-9a04-b8de4c8ea862&embed=%7B%22ust%22%3Atrue%2C%22hv%22%3A%22CopyEmbedCode%22%7D&referrer=OneUpFileViewer&referrerScenario=EmbedDialog.Create" width="640" height="360" frameborder="0" scrolling="no" allowfullscreen title="Cap1_s3.mp4"></iframe>

### Spine plot

The aggregation plot you have drawn in the previous exercise gave you some high-level overview of the missing data. If you are interested in the interaction between specific variables, a spine plot is the way to go. It allows you to study the percentage of missing values in one variable for different values of the other, which is conceptually very similar to the t-tests you have been running in the previous lesson.

In this exercise, you will draw a spine plot to investigate the percentage of missing data in `earnings` for different categories of `sub_race`. Is there more missing data on `earnings` for some specific races of the movie's main character? Let's find out! The `VIM` package has already been loaded for you.



```{r}
# Draw a spine plot to analyse missing values in earnings by sub_race

biopics %>% 
	dplyr::select(sub_race,earnings) %>%
	spineMiss()
```
### Question

Based on the spine plot you have just created, which of the following statements is false?

Possible Answers

In the vast majority of movies, the main character is white.

When the main subject is African, we are the most likely to have complete earnings information.

As far as earnings and sub_race are concerned, the data seem to be MAR.

The race that appears most rarely in the data has around 40% of earnings missing. (incorrecta)

### Mosaic plot

The spine plot you have created in the previous exercise allows you to study missing data patterns between two variables at a time. This idea is generalized to more variables in the form of a mosaic plot.

In this exercise, you will start by creating a dummy variable indicating whether the United States was involved in the production of each movie. To do this, you will use the `grepl()` function, which checks if the string passed as its first argument is present in the object passed as its second argument. Then, you will draw a mosaic plot to see if the subject's gender correlates with the amount of missing data on `earnings` for both US and non-US movies.

The `biopics` data as well as the `VIM` package are already loaded for you. Let's do some exploratory plotting!

Note that a propriety `display_image()` function has been created to return the output from the latest `VIM` package version. Make sure to expand the `HTML Viewer` section.


```{r}
# Prepare data for plotting and draw a mosaic plot
biopics %>%
	# Create a dummy variable for US-produced movies
	mutate(is_US_movie = grepl("US", country)) %>%
	# Draw mosaic plot
	mosaicMiss(highlight = "earnings", 
             plotvars = c("is_US_movie", "sub_sex"))

# Return plot from latest VIM package - expand the HTML viewer section
#display_image()
```
# Chapter 2

## Sesión 1

<iframe src="https://inechile-my.sharepoint.com/personal/jibustosm_ine_gob_cl/_layouts/15/embed.aspx?UniqueId=f78f1a93-7207-4b6a-a12e-03b7aa0086ef&embed=%7B%22ust%22%3Atrue%2C%22hv%22%3A%22CopyEmbedCode%22%7D&referrer=OneUpFileViewer&referrerScenario=EmbedDialog.Create" width="640" height="360" frameborder="0" scrolling="no" allowfullscreen title="Cap2_s1.mp4"></iframe>

### Smelling the danger of mean imputation

One of the most popular imputation methods is the mean imputation, in which missing values in a variable are replaced with the mean of the observed values in this variable. However, in many cases this simple approach is a poor choice. Sometimes a quick look at the data can already alert you to the dangers of mean-imputing.

In this chapter, you will be working with a subsample of the Tropical Atmosphere Ocean (`tao`) project data. The dataset consists of atmospheric measurements taken in two different time periods at five different locations. The data comes with the `VIM` package.

In this exercise you will familiarize yourself with the data and perform a simple analysis that will indicate what the consequences of mean imputation could be. Let's take a look at the `tao` data!

```{r}
data(tao, package = "VIM")
names(tao)<-tolower(names(tao))
names(tao)<-sub("[.]", "_", names(tao))
names(tao)<-sub("[.]", "_", names(tao))

# Print first 10 observations
head(tao, 10)

# Get the number of missing values per column
tao %>%
  is.na() %>% 
  colSums()

# Calculate the number of missing values in air_temp per year
tao %>% 
  group_by(year) %>% 
  summarize(num_miss = sum(is.na(air_temp)))
```

### Mean-imputing the temperature

Mean imputation can be a risky business. If the variable you are mean-imputing is correlated with other variables, this correlation might be destroyed by the imputed values. You saw it looming in the previous exercise when you analyzed the air_temp variable.

To find out whether these concerns are valid, in this exercise you will perform mean imputation on `air_temp`, while also creating a binary indicator for where the values are imputed. It will come in handy in the next exercise, when you will be assessing your imputation's performance. Let's fill in those missing values!

```{r}
tao_imp <- tao %>% 
  # Create a binary indicator for missing values in air_temp
  mutate(air_temp_imp = ifelse(is.na(air_temp), TRUE, FALSE)) %>%
  # Impute air_temp with its mean
  mutate(air_temp = ifelse(is.na(air_temp), mean(air_temp, na.rm = TRUE), air_temp))

# Print the first 10 rows of tao_imp
head(tao_imp, 10)
```

### Assessing imputation quality with margin plot

In the last exercise, you have mean-imputed `air_temp` and added an indicator variable to denote which values were imputed, called `air_temp_imp`. Time to see how well this works.

Upon examining the `tao` data, you might have noticed that it also contains a variable called `sea_surface_temp`, which could reasonably be expected to be positively correlated with `air_temp`. If that's the case, you would expect these two temperatures to be both high or both low at the same time. Imputing mean air temperature when the sea temperature is high or low would break this relation.

To find out, in this exercise you will select the two temperature variables and the indicator variable and use them to draw a margin plot. Let's assess the mean imputation!




```{r}
# Draw a margin plot of air_temp vs sea_surface_temp
tao_imp %>% 
  select(air_temp, sea_surface_temp, air_temp_imp) %>%
  marginplot(delimiter = "imp")
```

## Sesión 2

<iframe src="https://inechile-my.sharepoint.com/personal/jibustosm_ine_gob_cl/_layouts/15/embed.aspx?UniqueId=1cfa3390-9ab6-435c-a468-330f2b157ef9&embed=%7B%22ust%22%3Atrue%2C%22hv%22%3A%22CopyEmbedCode%22%7D&referrer=OneUpFileViewer&referrerScenario=EmbedDialog.Create" width="640" height="360" frameborder="0" scrolling="no" allowfullscreen title="Cap2_s2.mp4"></iframe>

### Vanilla hot-deck

Hot-deck imputation is a simple method that replaces every missing value in a variable by the last observed value in this variable. It's very fast, as only one pass through the data is needed, but in its simplest form, hot-deck may sometimes break relations between the variables.

In this exercise, you will try it out on the tao dataset. You will hot-deck-impute missing values in the air temperature column `air_temp` and then draw a margin plot to analyze the relation between the imputed values with the sea surface temperature column `sea_surface_temp`. Let's see how it works!

```{r}
# Load VIM package
library(VIM)

# Impute air_temp in tao with hot-deck imputation
tao_imp <- hotdeck(tao, variable = "air_temp")

# Check the number of missing values in each variable
tao_imp %>% 
	is.na() %>% 
	colSums()

# Draw a margin plot of air_temp vs sea_surface_temp
tao_imp %>% 
	select(air_temp, sea_surface_temp, air_temp_imp) %>% 
	marginplot(delimiter = "imp")
```
 Does the imputation look good? Notice the observations in the top left part of the plot with imputed `air_temp` and high `sea_surface_temp`. These observations must have been preceded by ones with low `air_temp` in the data frame, and so after hot-deck imputation, they ended up being outliers with low `air_temp` and high sea_surface_temp.

### Hot-deck tricks & tips I: imputing within domains

One trick that may help when hot-deck imputation breaks the relations between the variables is imputing within domains. What this means is that if the variable to be imputed is correlated with another, categorical variable, one can simply run hot-deck separately for each of its categories.

For instance, you might expect air temperature to depend on time, as we are seeing the average temperatures rising due to global warming. The time indicator you have available in the tao data is a categorical variable, year. Let's first check if the average air temperature is different in each of the two studied years and then run hot-deck within year domains. Finally, you will draw the margin plot again to assess the imputation performance.

```{r}
# Calculate mean air_temp per year
tao %>% 
	group_by(year) %>% 
	summarize(average_air_temp = mean(air_temp, na.rm = TRUE))

# Hot-deck-impute air_temp in tao by year domain
tao_imp <- hotdeck(tao, variable = "air_temp", domain_var = "year")

# Draw a margin plot of air_temp vs sea_surface_temp
tao_imp %>% 
	select(air_temp, sea_surface_temp, air_temp_imp) %>% 
	marginplot(delimiter = "imp")
```
The results look much better this time. However, if you look at the top right corner of the plot, you will see that the variance in the imputed (orange) values is somewhat larger than among the observed (blue) values. Let's see if we can improve even further in the next exercise!


### Hot-deck tricks & tips II: sorting by correlated variables

Another trick that can boost the performance of hot-deck imputation is sorting the data by variables correlated to the one we want to impute.

For instance, in all the margin plots you have been drawing recently, you have seen that air temperature is strongly correlated with sea surface temperature, which makes a lot of sense. You can exploit this knowledge to improve your hot-deck imputation. If you first order the data by sea_surface_temp, then every imputed air_temp value will come from a donor with a similar sea_surface_temp. Let's see how this will work!


```{r}
# Hot-deck-impute air_temp in tao ordering by sea_surface_temp
tao_imp <- hotdeck(tao, variable = "air_temp", ord_var = "sea_surface_temp")

# Draw a margin plot of air_temp vs sea_surface_temp
tao_imp %>% 
	select(air_temp, sea_surface_temp, air_temp_imp) %>% 
	marginplot(delimiter = "imp")
```

This time the imputation seems not to impact the relation between air and sea temperatures: if not for the colors, you likely wouldn't know which ones are the imputed values. Hot-deck imputation, possibly enhanced with domain-imputing or sorting, is a fast and simple method that can serve you well in many situations. However, sometimes you may need a more complex approach. 

## Sesión 3

<iframe src="https://inechile-my.sharepoint.com/personal/jibustosm_ine_gob_cl/_layouts/15/embed.aspx?UniqueId=87d51354-68c7-46ae-bbd9-4c0a35da474c&embed=%7B%22ust%22%3Atrue%2C%22hv%22%3A%22CopyEmbedCode%22%7D&referrer=OneUpFileViewer&referrerScenario=EmbedDialog.Create" width="640" height="360" frameborder="0" scrolling="no" allowfullscreen title="Cap2_s3.mp4"></iframe>

### Choosing the number of neighbors

k-Nearest-Neighbors (or kNN) imputation fills the missing values in an observation based on the values coming from the k other observations that are most similar to it. The number of these similar observations, called neighbors, that are considered is a parameter that has to be chosen beforehand.

How to choose k? One way is to try different values and see how they impact the relations between the imputed and observed data.

Let's try imputing `humidity` in the `tao` data using three different values of k and see how the imputed values fit the relation between `humidity` and `sea_surface_temp`.


Impute `humidity` with kNN imputation using 30 neighbors and draw a `marginplot()` of `sea_surface_temp` vs `humidity`.

```{r}
# Impute humidity using 30 neighbors
tao_imp <- kNN(tao, k = 30, variable = "humidity")

# Draw a margin plot of sea_surface_temp vs humidity
tao_imp %>% 
	select(sea_surface_temp, humidity, humidity_imp) %>% 
	marginplot(delimiter = "imp", main = "k = 30")
```

Impute `humidity` with kNN imputation using 15 neighbors and draw a `marginplot` of `sea_surface_temp` vs `humidity`.

```{r}
# Impute humidity using 15 neighbors
tao_imp <- kNN(tao, k = 15, variable = "humidity")

# Draw a margin plot of sea_surface_temp vs humidity
tao_imp %>% 
	select(sea_surface_temp, humidity, humidity_imp) %>% 
	marginplot(delimiter = "imp", main = "k = 15")
```

Impute `humidity` with kNN imputation using 5 neighbors and draw a `marginplot` of `sea_surface_temp` vs `humidity`.


```{r}
# Impute humidity using 5 neighbors
tao_imp <- kNN(tao, k = 5, variable = "humidity")

# Draw a margin plot of sea_surface_temp vs humidity
tao_imp %>% 
	select(sea_surface_temp, humidity, humidity_imp) %>% 
	marginplot(delimiter = "imp", main = "k = 5")
```

### kNN tricks & tips I: weighting donors

A variation of `kNN` imputation that is frequently applied uses the so-called distance-weighted aggregation. What this means is that when we aggregate the values from the neighbors to obtain a replacement for a missing value, we do so using the weighted mean and the weights are inverted distances from each neighbor. As a result, closer neighbors have more impact on the imputed value.

In this exercise, you will apply the distance-weighted aggregation while imputing the `tao` data. This will only require passing two additional arguments to the `kNN()` function. Let's try it out!


```{r}
# Load the VIM package
library(VIM)

# Impute humidity with kNN using distance-weighted mean
tao_imp <- kNN(tao, 
               k = 5, 
               variable = "humidity", 
               numFun = weighted.mean,
               weightDist = TRUE)

tao_imp %>% 
	select(sea_surface_temp, humidity, humidity_imp) %>% 
	marginplot(delimiter = "imp")
```
### kNN tricks & tips II: sorting variables

As the k-Nearest Neighbors algorithm loops over the variables in the data to impute them, it computes distances between observations using other variables, some of which have already been imputed in the previous steps. This means that if the variables located earlier in the data have a lot of missing values, then the subsequent distance calculation is based on a lot of imputed values. This introduces noise to the distance calculation.

For this reason, it is a good practice to sort the variables increasingly by the number of missing values before performing kNN imputation. This way, each distance calculation is based on as much observed data and as little imputed data as possible.

Let's try this out on the `tao` data!

```{r}
# Get tao variable names sorted by number of NAs
vars_by_NAs <- tao %>%
  is.na() %>%
  colSums() %>%
  sort(decreasing = FALSE) %>% 
  names()

# Sort tao variables and feed it to kNN imputation
tao_imp <- tao %>% 
  select(vars_by_NAs) %>% 
  kNN(k= 5)

tao_imp %>% 
	select(sea_surface_temp, humidity, humidity_imp) %>% 
	marginplot(delimiter = "imp")
```
The kNN you have just coded should be more accurate and robust against faulty imputations, so remember to sort your variables first before performing kNN imputation! This brings us to the end of this chapter. Keep it up! See you in Chapter 3, where you will learn to use statistical and machine learning models to impute missing values!

# Chapter 3

## Sesión 1

<iframe src="https://inechile-my.sharepoint.com/personal/jibustosm_ine_gob_cl/_layouts/15/embed.aspx?UniqueId=97f92ec7-7bf2-4632-8ea2-c055fd31e269&embed=%7B%22ust%22%3Atrue%2C%22hv%22%3A%22CopyEmbedCode%22%7D&referrer=OneUpFileViewer&referrerScenario=EmbedDialog.Create" width="640" height="360" frameborder="0" scrolling="no" allowfullscreen title="Cap3_s1.mp4"></iframe>

### Linear regression imputation

Sometimes, you can use domain knowledge, previous research or simply your common sense to describe the relations between the variables in your data. In such cases, model-based imputation is a great solution, as it allows you to impute each variable according to a statistical model that you can specify yourself, taking into account any assumptions you might have about how the variables impact each other.

For continuous variables, a popular model choice is linear regression. It doesn't restrict you to linear relations though! You can always include a square or a logarithm of a variable in the predictors. In this exercise, you will work with the `simputation` package to run a single linear regression imputation on the `tao` data and analyze the results. Let's give it a try!


```{r, message=FALSE}
# Load the simputation package
library(simputation)

# Impute air_temp and humidity with linear regression
formula <- air_temp + humidity ~ year + latitude + sea_surface_temp
tao_imp <- impute_lm(tao, formula)
```




```{r}
# Load the simputation package
library(simputation)

# Impute air_temp and humidity with linear regression
formula <- air_temp + humidity ~ year + latitude + sea_surface_temp
tao_imp <- impute_lm(tao, formula)

# Check the number of missing values per column
tao_imp %>% 
  is.na() %>% 
  colSums()

# Print rows of tao_imp in which air_temp or humidity are still missing 
tao_imp %>% 
  filter(is.na(air_temp) | is.na(humidity))
```

Linear regression fails when at least one of the predictors is missing. In this case, it was sea_surface_temp. In the next exercise, you will fix it by initializing the missing values before running `impute_lm()`!



### Initializing missing values & iterating over variables

As you have just seen, running `impute_lm()` might not fill-in all the missing values. To ensure you impute all of them, you should initialize the missing values with a simple method, such as the hot-deck imputation you learned about in the previous chapter, which simply feeds forward the last observed value.

Moreover, a single imputation is usually not enough. It is based on the basic initialized values and could be biased. A proper approach is to iterate over the variables, imputing them one at a time in the locations where they were originally missing.

In this exercise, you will first initialize the missing values with hot-deck imputation and then loop five times over `air_temp` and `humidity` from the `tao` data to impute them with linear regression. Let's get to it!


```{r}
# Initialize missing values with hot-deck
tao_imp <- hotdeck(tao)

# Create boolean masks for where air_temp and humidity are missing
missing_air_temp <- tao_imp$air_temp_imp
missing_humidity <- tao_imp$humidity_imp

for (i in 1:5) {
  # Set air_temp to NA in places where it was originally missing and re-impute it
  tao_imp$air_temp[missing_air_temp] <- NA
  tao_imp <- impute_lm(tao_imp, air_temp ~ year + latitude + sea_surface_temp + humidity)
  # Set humidity to NA in places where it was originally missing and re-impute it
  tao_imp$humidity[missing_humidity] <- NA
  tao_imp <- impute_lm(tao_imp, humidity ~ year + latitude + sea_surface_temp + air_temp)
}
```
That's a professional approach to model-based imputation you have just coded! But how do we know that 5 is the proper number of iterations to run? Let's look at the convergence in the next exercise!


### Detecting convergence

Great job iterating over the variables in the last exercise! But how many iterations are needed? When the imputed values don't change with the new iteration, we can stop.

You will now extend your code to compute the differences between the imputed variables in subsequent iterations. To do this, you will use the Mean Absolute Percentage Change function, defined for you as follows:

`mapc <- function(a, b) {
  mean(abs(b - a) / a, na.rm = TRUE)
}`

`mapc()` outputs a single number that tells you how much b differs from a. You will use it to check how much the imputed variables change across iterations. Based on this, you will decide how many of them are needed!

The boolean masks `missing_air_temp` and `missing_humidity` are available for you, as is the hotdeck-initialized `tao_imp` data.



```{r}
mapc<- function(a, b) {
  mean(abs(b - a) / a, na.rm = TRUE)
}

```

```{r}
diff_air_temp <- c()
diff_humidity <- c()

for (i in 1:5) {
  # Assign the outcome of the previous iteration (or initialization) to prev_iter
  prev_iter <- tao_imp
  # Impute air_temp and humidity at originally missing locations
  tao_imp$air_temp[missing_air_temp] <- NA
  tao_imp <- impute_lm(tao_imp, air_temp ~ year + latitude + sea_surface_temp + humidity)
  tao_imp$humidity[missing_humidity] <- NA
  tao_imp <- impute_lm(tao_imp, humidity ~ year + latitude + sea_surface_temp + air_temp)
  # Calculate MAPC for air_temp and humidity and append them to previous iteration's MAPCs
  diff_air_temp <- c(diff_air_temp, mapc(prev_iter$air_temp, tao_imp$air_temp))
  diff_humidity <- c(diff_humidity, mapc(prev_iter$humidity, tao_imp$humidity))
}
```

### Question

Based on the differences stored in `diff_air_temp` and `diff_humidity`, what is the sufficient number of iterations to run?

To answer this question, you can print the two vectors in the console and analyze the numbers, or plot them using the function provided for you: just run `plot_diffs(diff_air_temp, diff_humidity)` in the console.



```{r}
plot_diffs <- function(a, b) {
  data.frame("mapc" = c(a, b),
             "Variable" = c(rep("air_temp", length(a)),
                            rep("humidity", length(b))),
             "Iterations" = c(1:length(a), 1:length(b))) %>% 
    ggplot(aes(Iterations, mapc, color = Variable)) +
    geom_line(size = 1.5) +
    ylab("Mean absolute percentage change") +
    ggtitle("Changes in imputed variables' values across iterations") +
    theme(legend.position = "bottom")
}
```


```{r}
plot_diffs(diff_air_temp, diff_humidity)
```
## Sesión 2

<iframe src="https://inechile-my.sharepoint.com/personal/jibustosm_ine_gob_cl/_layouts/15/embed.aspx?UniqueId=d15f9bf6-7ddf-433d-b6e8-f00faafa283e&embed=%7B%22ust%22%3Atrue%2C%22hv%22%3A%22CopyEmbedCode%22%7D&referrer=OneUpFileViewer&referrerScenario=EmbedDialog.Create" width="640" height="360" frameborder="0" scrolling="no" allowfullscreen title="video (35).mp4"></iframe>

### Logistic regression imputation

A popular choice for imputing binary variables is logistic regression. Unfortunately, there is no function similar to `impute_lm()` that would do it. That's why you'll write such a function yourself!

Let's call the function `impute_logreg()`. Its first argument will be a data frame `df`, whose missing values have been initialized and only containing missing values in the column to be imputed. The second argument will be a formula for the logistic regression model.

The function will do the following:

Keep the locations of missing values.
Build the model.
Make predictions.
Replace missing values with predictions.
Don't worry about the line creating `imp_var` - this is just a way to extract the name of the column to impute from the formula. Let's do some functional programming!

```{r}
impute_logreg <- function(df, formula) {
  # Extract name of response variable
  imp_var <- as.character(formula[2])
  # Save locations where the response is missing
  missing_imp_var <- is.na(df[imp_var])
  # Fit logistic regression mode
  logreg_model <- glm(formula, data = df, family = binomial)
  # Predict the response and convert it to 0s and 1s
  preds <- predict(logreg_model, type = "response")
  preds <- ifelse(preds >= 0.5, 1, 0)
  # Impute missing values with predictions
  df[missing_imp_var, imp_var] <- preds[missing_imp_var]
  return(df)
}
```

The function you wrote is fully operational and can be plugged-in to the loop over the variables you have seen in the previous chapter, just like `impute_lm()` from the `simputation` package. Shortly, you will combine these two to impute both continuous and binary variables! But before that, let's enhance your `impute_logreg()` to make it replicate the variability in imputed data better.


### Drawing from conditional distribution

Simply calling `predict()` on a model will always return the same value for the same values of the predictors. This results in a small variability in imputed data. In order to increase it, so that the imputation replicates the variability from the original data, we can draw from the conditional distribution. What this means is that instead of always predicting 1 whenever the model outputs a probability larger than 0.5, we can draw the prediction from a binomial distribution described by the probability returned by the model.

You will work on the code you have written in the previous exercise. The following line was removed:

`preds <- ifelse(preds >= 0.5, 1, 0)`

Your task is to fill its place with drawing from a binomial distribution. That's just one line of code!

```{r}
 impute_logreg <- function(df, formula) {
  # Extract name of response variable
  imp_var <- as.character(formula[2])
  # Save locations where the response is missing
  missing_imp_var <- is.na(df[imp_var])
  # Fit logistic regression mode
  logreg_model <- glm(formula, data = df, family = binomial)
  # Predict the response
  preds <- predict(logreg_model, type = "response")
  # Sample the predictions from binomial distribution
  # preds <- ifelse(preds >= 0.5, 1, 0)
  preds <- rbinom(length(preds), size = 1, prob = preds)
  # Impute missing values with predictions
  df[missing_imp_var, imp_var] <- preds[missing_imp_var]
  return(df)
}
```

Drawing from the conditional distribution will make the imputed data's variability more similar to the one of original, observed data. With this powerful function at hand, you are now ready to design a model-based imputation flow that takes care of both continuous and binary variables. Let's do it in the next exercise!


### Model-based imputation with multiple variable types

Great job on writing the function to implement logistic regression imputation with drawing from conditional distribution. That's pretty advanced statistics you have coded! In this exercise, you will combine what you learned so far about model-based imputation to impute different types of variables in the tao data.

Your task is to iterate over variables just like you have done in the previous chapter and impute two variables:

`is_hot`, a new binary variable that was created out of `air_temp`, which is 1 if `air_temp` is at or above 26 degrees and is 0 otherwise;
`humidity`, a continuous variable you are already familiar with.
You will have to use the linear regression function you have learned before, as well as your own function for logistic regression. Let's get to it!


```{r}
tao$is_hot<-ifelse(tao$air_temp>= 26, 1,0)
```


```{r}
# Initialize missing values with hot-deck
tao_imp <- hotdeck(tao)

# Create boolean masks for where is_hot and humidity are missing
missing_is_hot <- tao_imp$is_hot_imp
missing_humidity <- tao_imp$humidity_imp

for (i in 1:3) {
  # Set is_hot to NA in places where it was originally missing and re-impute it
  tao_imp$is_hot[missing_is_hot] <- NA
  tao_imp <- impute_logreg(tao_imp, is_hot ~ sea_surface_temp)
  # Set humidity to NA in places where it was originally missing and re-impute it
  tao_imp$humidity[missing_humidity] <- NA
  tao_imp <- impute_lm(tao_imp, humidity ~ sea_surface_temp + air_temp)
}
```

## Sesión 3

<iframe src="https://inechile-my.sharepoint.com/personal/jibustosm_ine_gob_cl/_layouts/15/embed.aspx?UniqueId=96468941-b396-4307-9514-a983b777a51a&embed=%7B%22ust%22%3Atrue%2C%22hv%22%3A%22CopyEmbedCode%22%7D&referrer=OneUpFileViewer&referrerScenario=EmbedDialog.Create" width="640" height="360" frameborder="0" scrolling="no" allowfullscreen title="Cap3_s3.mp4"></iframe>

### Imputing with random forests

A machine learning approach to imputation might be both more accurate and easier to implement compared to traditional statistical models. First, it doesn't require you to specify relationships between variables. Moreover, machine learning models such as random forests are able to discover highly complex, non-linear relations and exploit them to predict missing values.

In this exercise, you will get acquainted with the `missForest` package, which builds a separate random forest to predict missing values for each variable, one by one. You will call the imputing function on the biographic movies data, `biopics`, which you have worked with earlier in the course and then extract the filled-in data as well as the estimated imputation errors.

Let's plant some random forests!

```{r}
biopics <- read.csv("~/edi_imp/handing/biopics.csv")
# Load the missForest package
library(missForest)

# Impute biopics data using missForest
imp_res <- missForest(biopics)

# Extract imputed data and check for missing values
imp_data <- imp_res$ximp
print(sum(is.na(imp_data)))

# Extract and print imputation errors
imp_err <- imp_res$OOBerror
print(imp_err)
```

### Variable-wise imputation errors

In the previous exercise you have extracted the estimated imputation errors from `missForest`'s output. This gave you two numbers:

the normalized root mean squared error (NRMSE) for all continuous variables;
the proportion of falsely classified entries (PFC) for all categorical variables.
However, it could well be that the imputation model performs great for one continuous variable and poor for another! To diagnose such cases, it is enough to tell `missForest` to produce variable-wise error estimates. This is done by setting the `variablewise` argument to `TRUE`.

The `biopics` data and `missForest` package have already been loaded for you, so let's take a closer look at the errors!


```{r}
# Impute biopics data with missForest computing per-variable errors
imp_res <- missForest(biopics, variablewise = TRUE)

# Extract and print imputation errors
per_variable_errors <- imp_res$OOBerror
print(per_variable_errors)

# Rename errors' columns to include variable names
names(per_variable_errors) <- paste(names(biopics), 
                                    names(per_variable_errors),
                                    sep = "_")

# Print the renamed errors
print(per_variable_errors)
```
Notice how you produced a range of error measures instead of the default two you've seen before. You can now assess impuation quality for each variable separately! This is handy when you need to know how the model performs for a particular variable that you want to further model or analyze.

### Speed-accuracy trade-off

In the last video, you have seen there are two knobs you can tune to influence the performance of the random forests:

Number of decision trees in each forest.
Number of variables used for splitting within decision trees.
Increasing each of them might improve the accuracy of the imputation model, but it will also require more time to run. In this exercise, you will explore these ideas yourself by fitting `missForest()` to the `biopics` data twice with different settings. As you follow the instructions, pay attention to the errors you will be printing, and to the time the code takes to run.

```{r}
# Set number of trees to 5 and number of variables used for splitting to 2
imp_res <- missForest(biopics, mtry = 2, ntree = 5)

# Print the resulting imputation errors
print(imp_res$OOBerror)
```

```{r}
# Set number of trees to 50 and number of variables used for splitting to 6
imp_res <- missForest(biopics, mtry = 6, ntree = 50)

# Print the resulting imputation errors
print(imp_res$OOBerror)
```
Compare the errors and the run times of the two imputation models. Can you see a relation? There ain't no such thing as a free lunch, they say. To get a more precise imputation, you had to spend more in computing time! Congratulations on finishing the chapter! See you in the final chapter, where you will learn to incorporate uncertainty from imputation into your analyses and predictions.

# Chapter 4

## Sesión 1

<iframe src="https://inechile-my.sharepoint.com/personal/jibustosm_ine_gob_cl/_layouts/15/embed.aspx?UniqueId=ace0869c-215f-44e0-86f8-a7d69b3464c6&embed=%7B%22ust%22%3Atrue%2C%22hv%22%3A%22CopyEmbedCode%22%7D&referrer=OneUpFileViewer&referrerScenario=EmbedDialog.Create" width="640" height="360" frameborder="0" scrolling="no" allowfullscreen title="Cap4_s1.mp4"></iframe>

### Wrapping imputation & modeling in a function

Whenever you perform any analysis or modeling on imputed data, you should account for the uncertainty from imputation. Running a model on a dataset imputed only once ignores the fact that imputation estimates the missing values with uncertainty. Standard errors from such a model tend to be too small. The solution to this is multiple imputation and one way to implement it is by bootstrapping.

In the upcoming exercises, you will work with the familiar `biopics` data. The goal is to use multiple imputation by bootstrapping and linear regression to see if, based on the data at hand, biographical movies featuring females earn less than those about males.

Let's start with writing a function that creates a bootstrap sample, imputes it, and fits a linear regression model.

```{r}
calc_gender_coef <- function(data, indices) {
  # Get bootstrap sample
  data_boot <- data[indices, ]
  # Impute with kNN imputation
  data_imp <- kNN(data_boot, k = 5)
  # Fit linear regression
  linear_model <- lm(earnings ~ sub_sex + sub_type + year, data = data_imp)
  # Extract and return gender coefficient
  gender_coefficient <- coef(linear_model)[2]
  return(gender_coefficient)
}
```

The `calc_gender_coef()` function you have just coded takes the data and bootstrap indices as inputs, and outputs our statistic of interest - the impact of gender on earnings from linear regression. You can now feed this function to the bootstrapping algorithm!

### Running the bootstrap

Good job writing `calc_gender_coef()` in the last exercise! This function creates a bootstrap sample, imputes it and, outputs the linear regression coefficient describing the impact of movie subject's being a female on the movie's earnings.

In this exercise, you will use the `boot` package in order to obtain a bootstrapped distribution of such coefficients. The spread of this distribution will capture the uncertainty from imputation. You will also look at how the bootstrapped distribution differs from a single-time imputation and regression. Let's do some bootstrapping!


```{r}
# Load the boot library
library(boot)

# Run bootstrapping on biopics data
boot_results <- boot(biopics, statistic = calc_gender_coef, R = 50)

# Print and plot bootstrapping results
print(boot_results)
plot(boot_results)
```

Fantastic bootstrapping! If you had run the `kNN` imputation and the regression analysis on `biopics` data only once, you would have obtained the female-coefficient of -1.45 (called 'original' in the console output), suggesting that movies about females indeed earn less. However, correcting for the uncertainty from imputation, you have obtained the distribution that covers both negative and postive values!


### Bootstrapping confidence intervals

Having bootstrapped the distribution of the female-effect coefficient in the last exercise, you can now use it to estimate a confidence interval. It will allow you to make the following assessment about your data: "Given the uncertainty from imputation, we are 95% sure that the female-effect on earnings is between a and b", where a and b are the lower and upper bounds of the interval.

In the last exercise, you have run bootstrapping with `R = 50` replicates. In most applications, however, this is not enough. In this exercise, you can use `boot_results` that were prepared for you using 1000 replicates. First, you will look at the bootstrapped distribution to see if it looks normal. If so, you can then rely on the normal distribution to calculate the confidence interval.

```{r}
# Run bootstrapping on biopics data
#boot_results <- boot(biopics, statistic = calc_gender_coef, R = 1000)
```


```{r}
# Plot and print boot_results
plot(boot_results)
print(boot_results)

# Calculate and print confidence interval
boot_ci <- boot.ci(boot_results, conf = 0.95, type = "norm")
print(boot_ci)
```

Despite it leaning to be a negative relationship, bootstrap replicates show that some movies with female leads actually earn more! Accounting for the uncertainty from imputation, you cannot be 100% sure about the direction of this relation, even though a single analysis suggests otherwise.


## Sesión 2

<iframe src="https://inechile-my.sharepoint.com/personal/jibustosm_ine_gob_cl/_layouts/15/embed.aspx?UniqueId=2198a22f-9dde-4980-9acf-f27a7ed5b5c7&embed=%7B%22ust%22%3Atrue%2C%22hv%22%3A%22CopyEmbedCode%22%7D&referrer=OneUpFileViewer&referrerScenario=EmbedDialog.Create" width="640" height="360" frameborder="0" scrolling="no" allowfullscreen title="Cap4_s2.mp4"></iframe>

### The mice flow: mice - with - pool

Multiple imputation by chained equations, or `MICE`, allows us to estimate the uncertainty from imputation by imputing a data set multiple times with **model-based imputation**, while drawing from conditional distributions. This way, each imputed data set is slightly different. Then, an analysis is conducted on each of them and the results are pooled together, yielding the quantities of interest, alongside their confidence intervals that reflect the imputation uncertainty.

In this exercise, you will practice the typical MICE flow: `mice()` - `with()` - `pool()`. You will perform a regression analysis on the `biopics` data to see which subject occupation, `sub_type`, is associated with highest movie earnings. Let's play with mice!



```{r}
# Load mice package
library(mice)

# Impute biopics with mice using 5 imputations
biopics_multiimp <- mice(biopics, m = 5, seed = 3108)

# Fit linear regression to each imputed data set 
lm_multiimp <- with(biopics_multiimp, lm(earnings ~ year + sub_type))

# Pool and summarize regression results
lm_pooled <- pool(lm_multiimp)
summary(lm_pooled, conf.int = TRUE, conf.level = 0.95)
```

You have followed the mice - with - pool flow to impute, model and pool the results. Now take a look at the console output: a couple of `sub_types` have a positive impact on earnings. However, accounting for imputation uncertainty with 95% confidence, we are never sure of these effects, as the lower bounds are negative! With one exception: for `sub_typeAthlete / military`, both upper and lower bounds are positive. What we can say for sure is thus that movies about military athletes are popular!


### Choosing default models

MICE creates a separate imputation model for each variable in the data. What kind of model it is depends on the type of the variable in question. A popular way to specify the kinds of models we want to use is set a default model for each of the four variable types.

You can do this by passing the defaultMethod argument to `mice()`, which should be a vector of length 4 containing the default imputation methods for:

1. Continuous variables,
2. Binary variables,
3. Categorical variables (unordered factors),
4. Factor variables (ordered factors).

In this exercise, you will take advantage of mice's documentation to view the list of available methods and to pick the desired ones for the algorithm to use. Let's do some model selection!


```{r}
# Impute biopics using the methods specified in the instruction
biopics_multiimp <- mice(biopics, m = 20, 
                         defaultMethod = c("cart", "lda", "pmm", "polr"))

# Print biopics_multiimp
print(biopics_multiimp)
```

The ability to specify imputation models might come in handy when you see some specific methods underperforming. Another factor influencing how the imputation methods work is the set of predictors they use. Let's look at how to set these in the next exercise.


### Using predictor matrix

An important decision that needs to be taken when using model-based imputation is which variables should be included as predictors, and in which models. In `mice()`, this is governed by the predictor matrix and by default, all variables are used to impute all others.

In case of many variables in the data or little time to do a proper model selection, you can use `mice`'s functionality to create a predictor matrix based on the correlations between the variables. This matrix can then be passed to `mice()`. In this exercise, you will practice exactly this: you will first build a predictor matrix such that each variable will be imputed using variables most correlated to it; then, you will feed your predictor matrix to the imputing function. Let's try this simple model selection!

```{r}
# Create predictor matrix with minimum correlation of 0.1
pred_mat <- quickpred(biopics, mincor = 0.1)

# Impute biopics with mice
biopics_multiimp <- mice(biopics, 
                         m = 10, 
                         predictorMatrix = pred_mat,
                         seed = 3108)

# Print biopics_multiimp
print(biopics_multiimp)
```
## Sesión 3

<iframe src="https://inechile-my.sharepoint.com/personal/jibustosm_ine_gob_cl/_layouts/15/embed.aspx?UniqueId=187b8e2e-460d-490d-a02d-f9ccda959327&embed=%7B%22ust%22%3Atrue%2C%22hv%22%3A%22CopyEmbedCode%22%7D&referrer=OneUpFileViewer&referrerScenario=EmbedDialog.Create" width="640" height="360" frameborder="0" scrolling="no" allowfullscreen title="Cap4_s3.mp4"></iframe>

### Analyzing missing data patterns

The first step in working with incomplete data is to gain some insights into the missingness patterns, and a good way to do it is with visualizations. You will start your analysis of the `africa` data with employing the `VIM` package to create two visualizations: the aggregation plot and the spine plot. They will tell you how many data are missing, in which variables and configurations, and whether we can say something about the missing data mechanism. Let's kick off with some plotting!



```{r}
africa <- read.csv("~/edi_imp/handing/africa.csv", sep = ";")
```


```{r}
# Load VIM
library(VIM)



# Draw a combined aggregation plot of africa
africa %>%
  aggr(combined = TRUE, numbers = TRUE)
```

```{r}
# Draw a spine plot of country vs trade
africa %>% 
  select(country, trade) %>%
  spineMiss()
```

#### Question

Based on the spine plot you have just created, which of the following statements is TRUE?

Possible Answers

1. There is more missing data in trade for Cameroon than for Burundi.

2. There is more missing data in gdp_pc for Burundi than for Cameroon.

3. **There is no country with more than 20% trade values missing.**

Correct, there are not that many missing values! Also, notice from the spine plot that the africa data seem to be MAR - at least with respect to the GDP and country, which means it can be imputed.


### Imputing and inspecting outcomes

Good job on visualizing missing data in the previous exercise! You have discovered there are some missing entries in GDP, `gdp_pc`, and trade as percentage of GDP, trade. Also, you suspect the data are MAR, and thus imputable. In this exercise, you will make use of multiple imputation from the `mice` package to impute the `africa` data. Then, you will draw a strip plot of `gdp_pc` vs `trade` to see if the imputed data do not break the relation between these variables. Let mice do the job!


```{r}
# Load mice
library(mice)

# Impute africa with mice
africa_multiimp <- mice(africa, m = 5, defaultMethod = "cart", seed = 3108)

# Draw a stripplot of gdp_pc versus trade
stripplot(africa_multiimp, gdp_pc ~ trade | .imp, pch = 20, cex = 1)
```

It seems the imputation works well: there are small clusters in the scatter plots, likely corresponding to different countries. Each imputed data point fits into one of the clusters, instead of being an outlier somewhere between the clusters. Having done the imputation, you can now proceed to modeling!


### Inference with imputed data

In the last exercise, you have run `mice` to multiply impute the `africa` data. In this one, you will implement the other two steps of the mice - with - pool flow you've learned about earlier in the course. The model of interest is a linear regression that explains the GDP, `gdp_pc`, with other variables. You are particularly interested in the coefficient of civil liberties, `civlib`. Is more liberty associated with more economic growth once we incorporate the uncertainty from imputation? Let's find out!

```{r}
# Fit linear regression to each imputed data set
lm_multiimp <- with(africa_multiimp, lm(gdp_pc ~ country + year + trade + infl + civlib))

# Pool regression results
lm_pooled <- pool(lm_multiimp)

# Summarize pooled results
summary(lm_pooled, conf.int = TRUE, conf.level = 0.9)
```

#### Question

Based on the summary of the pooled regression results that you have just printed to the console, which of the following statements about the civil liberties in Africa is false?

Possible Answers

1. On average, more liberty is associated with higher GDP.

2. There is 5% chance that civlib's coefficient in regression on gdp_pc is larger than 342.154078.

3. **Based on the 90% confidence interval, we are sure that civlib's impact on gdp_pc is positive.**

Correct, this one is false! Since the lower and upper bounds have different signs, we cannot be sure of the direction of the effect. Congratulations, you have come a long way and learned a lot. Well done! Let's sum it all up in the final video of the course.


# Final remarks

<iframe src="https://inechile-my.sharepoint.com/personal/jibustosm_ine_gob_cl/_layouts/15/embed.aspx?UniqueId=c73c5f54-742e-4805-86a6-d4641279c64f&embed=%7B%22ust%22%3Atrue%2C%22hv%22%3A%22CopyEmbedCode%22%7D&referrer=OneUpFileViewer&referrerScenario=EmbedDialog.Create" width="640" height="360" frameborder="0" scrolling="no" allowfullscreen title="Cap4_s4.mp4"></iframe>


1. Final remarks
Congratulations on making it until the end of the course! Let's recap what you have learned.

2. What you know
In Chapter 1, you saw how modeling incomplete data can be troublesome and that it requires a special treatment. You also learned about the three missing data mechanisms and how to gain insights into missing data patterns by using visualizations from the VIM package and statistical tests. In Chapter 2, we covered donor-based imputation. First, you've seen why mean imputation is typically a poor choice. Then, you learned to use hot-deck and kNN imputation from the VIM package, along with some tricks that make them work even better.

3. What you know
In Chapter 3, you learned the model-based imputation approach of looping over variables and imputing them until convergence. You've also seen how to increase variability of imputed data by drawing from conditional distributions. Finally, you've learned about tree-based imputation with the missForest package. In Chapter 4, you've seen two methods of incorporating the uncertainty from imputation into modeling: bootstrapping using the boot package and multiple imputation by chained equations using the mice package.

4. Which imputation method to choose?
You learned about a lot of different imputation methods. Which one to choose and when? Here are some loose guidelines. If you have a lot of data or if your imputation has to run in real-time in production, you're best-off with the quick hot-deck. If you suspect specific relations between the variables based on domain knowledge, you can use this knowledge in model-based imputation. Otherwise, if the imputation need not be very fast and the relations between the variables are not obvious, a machine learning approach such as kNN or tree-based imputation is your best bet.

5. How to estimate uncertainty from imputation?
You've also learned about two methods to estimate the uncertainty from imputation: bootstrapping and mice. Which one to pick? Again, let me offer some loose guidelines. If your application has to be relatively fast or if you have ideas about which models to use and how to specify them, then mice is the way to go. Otherwise, if you would like to use a non-parametric method such as kNN or hot-deck, or if you simply don't want to worry about the assumptions of specific models, then the bootstrap might be a better choice.

6. Next steps
One last thing before you go. If you would like to dig even deeper into the arcane imputation knowledge, I suggest you google miceVignettes. The authors of the mice package provide a series of six vignettes with R code and examples which touch upon issues such as passive imputation, post-processing of imputed data, imputing multi-level data or sensitivity analysis. If you easily absorb knowledge from books, then "Flexible Imputation of Missing Data" by Stef van Buuren is a must-read. It also uses the mice package. Finally, there are some other great R packages worth exploring that we had no time to cover in this course, such as Amelia or mi, which allow for imputing time series and panel data.

7. Congratulations and good luck!
Once again, congratulations on finishing the course and thanks for staying with me. I hope the knowledge and skills you've gained will make your work with incomplete data easier and more productive. Good luck!
